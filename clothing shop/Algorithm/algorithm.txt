Giyim Mağazası Uygulaması: Detaylı Algoritma Rehberi (Güncellenmiş)
Bu projede temel hedefimiz, products.json dosyasından gelen geniş ürün yelpazesini, kullanıcının seçtiği filtrelere ve arama terimlerine göre anlık olarak güncelleyerek dinamik bir alışveriş deneyimi sunmak.

1. Veri Yükleme ve Yönetimi
Verilerin products.json dosyasından geleceğini biliyoruz. Bu, tarayıcının yerel ortamında bir API isteği gibi çalışacak ve sana önceki "Fake Store" projelerindeki fetch deneyimini kullanma fırsatı verecek.

JSON Dosyasını Çekme:

Uygulama başladığında (örneğin DOMContentLoaded olayı ile), fetch('./products.json') komutunu kullanarak JSON dosyasını çek.

Gelen yanıtı .json() metodu ile JavaScript objesine dönüştür.

Hata yakalamayı (promise catch bloğu) unutma; dosya bulunamazsa veya okunamazsa kullanıcıya bilgi verebilirsin.

Orjinal Ürün Verisini Saklama:

fetch işleminden başarılı dönen ürün dizisini allProducts adında sabit bir değişkende sakla (örneğin const allProducts = data;). Bu, uygulamanın yaşam döngüsü boyunca hiç değişmeyecek orijinal ve tam ürün listendir. Bu veri, her zaman tüm filtrelemelerin başlangıç noktası olacaktır.

Gösterilecek Ürün Verisini Saklama:

currentDisplayedProducts adında değişken bir kopya oluştur (örneğin let currentDisplayedProducts = [...allProducts];). Tüm filtreleme, arama ve sıralama işlemleri bu kopya üzerinde yapılacak ve sonuç bu değişkende tutulacak. HTML'e render edilecek ürünler de bu değişkenden alınacak.

2. Ürünleri Ekrana Yansıtma (Render) Algoritması
Bu, ürün listeni HTML'e dönüştürme ve gösterme işini yapacak temel fonksiyondur.

renderProducts(productsToRender) Fonksiyonu:

Bu fonksiyon, parametre olarak render edilecek ürünlerin dizisini (productsToRender) alır.

Öncelikle, ürünlerin listeleneceği HTML kapsayıcısının (örneğin div id="product-list") içeriğini tamamen temizle (örneğin innerHTML = '';). Bu, her güncellemede eski ürünlerin kalmamasını sağlar.

productsToRender dizisindeki her bir ürün için bir döngü başlat.

Her ürün için dinamik olarak bir HTML kartı (veya benzeri bir yapı) oluştur. Bu kart, ürünün name, price, image gibi bilgilerini içermeli.

Oluşturduğun HTML kartını ürün listesi kapsayıcısına ekle.

Hiç Ürün Yoksa: Eğer productsToRender dizisi boşsa (yani filtreler veya arama sonucu hiç eşleşen ürün bulunamazsa), kullanıcıya "Hiç ürün bulunamadı." gibi bilgilendirici bir mesaj göster.

İlk Yükleme: JSON verisi çekildikten hemen sonra renderProducts(currentDisplayedProducts) fonksiyonunu çağırarak tüm ürünleri ekranda göster.

3. Filtreleme ve Sıralama İşlemlerini Yönetme (Merkezi Algoritma)
Bu kısım projenin kalbidir. Kullanıcı herhangi bir filtreyi değiştirdiğinde veya arama yaptığında çalışacak tek bir merkezi fonksiyon oluşturacağız.

applyFiltersAndSort() Fonksiyonu:

Bu fonksiyon, bir filtre değiştiğinde veya arama yapıldığında çağrılacak ana fonksiyondur.

Başlangıç Noktası: Her çağrıldığında, filtreleme işlemine her zaman allProducts (orijinal, tam liste) üzerinden başla. Geçici bir değişken oluştur: let filteredAndSortedProducts = [...allProducts];

Aktif Filtre Durumlarını Toplama: Sayfadaki tüm filtre ve arama girişlerinin (cinsiyet, beden, renk seçimleri, arama metni, sıralama türü) o anki değerlerini al. Örneğin:

selectedGender: (örn. "male", "female", "unisex" veya "all")

selectedSizes: (örn. ["M", "L"] veya boş dizi)

selectedColors: (örn. ["Red", "Black"] veya boş dizi)

searchText: (örn. "tişört" veya boş string)

sortOrder: (örn. "price-asc" veya "price-desc")

Süzme (Filtreleme) Adımları (Zincirleme Uygulama): Her bir filtreyi filteredAndSortedProducts üzerinde uygula ve sonucu tekrar aynı değişkene ata. Bu, her yeni filtrenin önceki filtrelerin sonucunu daha da daraltmasını sağlar.

Cinsiyet Filtresi:

Eğer selectedGender "all" değilse veya boş değilse:

filteredAndSortedProducts dizisini filter() metoduyla süz.

Her ürün için, ürünün gender özelliği selectedGender ile eşleşiyor mu kontrol et.

Önemli Not: Eğer "male" seçiliyse, hem gender: "male" olan ürünler hem de gender: "unisex" olan ürünler gösterilmelidir (benzer şekilde "female" için de). Bu, gerçekçi bir senaryodur.

Beden Filtresi:

Eğer selectedSizes boş değilse:

filteredAndSortedProducts dizisini filter() metoduyla süz.

Her ürün için, ürünün sizes dizisi ile selectedSizes dizisi arasında en az bir ortak eleman olup olmadığını kontrol et (yani, kullanıcının seçtiği bedenlerden herhangi biri ürünün mevcut bedenleri arasındaysa).

Renk Filtresi:

Eğer selectedColors boş değilse:

filteredAndSortedProducts dizisini filter() metoduyla süz.

Her ürün için, ürünün colors dizisi ile selectedColors dizisi arasında en az bir ortak eleman olup olmadığını kontrol et.

Arama Filtresi (Ürün Adına Göre):

Eğer searchText boş değilse:

filteredAndSortedProducts dizisini filter() metoduyla süz.

Her ürünün name özelliğini searchText ile karşılaştır.

Karşılaştırma yaparken hem ürün adını hem de arama metnini küçük harfe çevir (toLowerCase()) ve includes() metodunu kullan. Bu, büyük/küçük harf duyarlılığını ortadan kaldırır.

Sıralama Adımı: Filtreleme bittikten sonra, filteredAndSortedProducts dizisini sırala.

Fiyat Sıralaması:

Eğer sortOrder "price-asc" ise: filteredAndSortedProducts.sort((a, b) => a.price - b.price);

Eğer sortOrder "price-desc" ise: filteredAndSortedProducts.sort((a, b) => b.price - a.price);

Ekranı Güncelleme:

Son olarak, currentDisplayedProducts = filteredAndSortedProducts; atamasını yap.

Ardından, renderProducts(currentDisplayedProducts) fonksiyonunu çağırarak güncellenmiş listeyi ekranda göster.

4. Olay Dinleyicileri (Event Listeners)
Tüm kullanıcı etkileşimlerini yakalamak ve applyFiltersAndSort() fonksiyonunu tetiklemek için olay dinleyicilerini kullanmalısın.

Cinsiyet Filtresi: Radyo butonları veya checkbox'lar için change olayını dinle. Her seçim değiştiğinde applyFiltersAndSort() çağrılmalı.

Beden Filtresi: Checkbox'lar veya select etiketi için change olayını dinle. Her seçim değiştiğinde applyFiltersAndSort() çağrılmalı.

Renk Filtresi: Checkbox'lar veya select etiketi için change olayını dinle. Her seçim değiştiğinde applyFiltersAndSort() çağrılmalı.

Fiyat Sıralaması: Radyo butonları veya select etiketi için change olayını dinle. Her seçim değiştiğinde applyFiltersAndSort() çağrılmalı.

Arama Çubuğu: input elementi için input olayını dinle. Kullanıcı yazdıkça anlık arama sonuçları görmek için bu önemlidir. Her input olayında applyFiltersAndSort() çağrılmalı.

5. Ek İyileştirmeler ve Hata Yönetimi
Filtreleri Temizle Butonu: Tüm filtreleri başlangıç durumuna (sıfırlanmış) getirecek bir buton ekle. Bu buton tıklandığında, tüm filtre seçimlerini temizle ve ardından applyFiltersAndSort() fonksiyonunu çağır.

Yükleme Durumu: fetch işlemi sırasında veya yoğun filtreleme anlarında kullanıcıya "Yükleniyor..." gibi bir mesaj gösterebilirsin.

Debounce (Arama için): Arama kutusuna her harf yazıldığında applyFiltersAndSort() fonksiyonunun hemen çalışması, çok hızlı klavye kullananlarda performansı etkileyebilir. debounce tekniği ile kullanıcının yazmayı bırakmasından kısa bir süre sonra (örn. 300ms) aramanın tetiklenmesini sağlayarak performansı artırabilirsin.

Kontrol Listesi (Yeniden Düzenlenmiş)
Bu adımları sırayla takip ederek projenin her bir parçasını inşa edebilir ve test edebilirsin.

I. Temel Kurulum ve Veri Yönetimi
[ ] Proje klasörü oluşturuldu (HTML, CSS, JS dosyaları).

[ ] products.json dosyası projenin ana dizinine yerleştirildi.

[ ] index.html içinde gerekli script ve stil bağlantıları yapıldı.

[ ] script.js (veya ana JS dosyan) içinde fetch('./products.json') ile veri çekme işlemi tanımlandı.

[ ] Çekilen veri const allProducts = data; şeklinde saklandı.

[ ] let currentDisplayedProducts = [...allProducts]; şeklinde gösterilecek ürünler için değişken kopya oluşturuldu.

[ ] Ürünlerin gösterileceği div id="product-list" gibi bir HTML kapsayıcısı hazırlandı.

[ ] renderProducts(productsToRender) fonksiyonu oluşturuldu:

[ ] HTML kapsayıcısının içini temizleme (innerHTML = '';).

[ ] productsToRender dizisindeki her ürün için HTML kartları oluşturma.

[ ] Oluşturulan kartları kapsayıcıya ekleme.

[ ] productsToRender boşsa "Ürün bulunamadı" mesajı gösterme mantığı eklendi.

[ ] Uygulama başladığında renderProducts(currentDisplayedProducts) çağrıldı.

II. Filtreleme ve Arama UI Elementleri
[ ] Cinsiyet Filtresi: Erkek, Kadın, Unisex seçenekleri için radyo butonları (veya benzeri) ve bir "Tümü" seçeneği eklendi.

[ ] Beden Filtresi: select elementi veya checkbox grubu ile beden seçenekleri (XS, S, M, L, XL, XXL, vb.) eklendi.

[ ] Renk Filtresi: select elementi veya checkbox grubu ile renk seçenekleri (White, Black, Red, Blue vb.) eklendi.

[ ] Fiyat Sıralaması: "Artan Fiyat" ve "Azalan Fiyat" seçenekleri için radyo butonları veya select elementi eklendi.

[ ] Ürün Adına Göre Arama: Bir input type="text" elementi (id="search-input") eklendi.

[ ] Tüm filtreleme ve sıralama kontrolleri için HTML'de mantıklı bir yerleşim sağlandı (örneğin bir yan panel veya üst çubuk).

[ ] Filtreleri sıfırlama butonu eklendi.

III. Merkezi Algoritma ve Olay Dinleyicileri
[ ] applyFiltersAndSort() adında ana JavaScript fonksiyonu oluşturuldu.

[ ] Bu fonksiyonun başında let filteredAndSortedProducts = [...allProducts]; ile her zaman orijinal veriden başlama mantığı uygulandı.

[ ] Fonksiyon içinde o anki tüm filtre ve arama değerlerini alma mantığı yazıldı.

[ ] filteredAndSortedProducts üzerinde cinsiyet filtreleme mantığı uygulandı (unisex ürünlerin ilgili cinsiyet filtrelerinde görünmesi dahil).

[ ] filteredAndSortedProducts üzerinde beden filtreleme mantığı uygulandı (çoklu beden seçimi desteği).

[ ] filteredAndSortedProducts üzerinde renk filtreleme mantığı uygulandı (çoklu renk seçimi desteği).

[ ] filteredAndSortedProducts üzerinde arama metni filtreleme mantığı uygulandı (küçük harf duyarsızlığı ile includes()).

[ ] Son filtrelenmiş liste üzerinde fiyata göre sıralama mantığı uygulandı (sort() metodu).

[ ] currentDisplayedProducts = filteredAndSortedProducts; ataması yapıldı.

[ ] renderProducts(currentDisplayedProducts); çağrısı ile ekran güncellendi.

[ ] Tüm filtreleme ve arama UI elementleri için ilgili olay dinleyicileri (örn. change, input) eklendi ve her olayda applyFiltersAndSort() fonksiyonu çağrıldı.

[ ] "Filtreleri Temizle" butonu için olay dinleyicisi eklendi; bu dinleyici tüm filtreleri sıfırlayıp applyFiltersAndSort()'u çağırıyor.

IV. Gelişmiş İyileştirmeler (İsteğe Bağlı ama Önemli)
[ ] Arama kutusu için debounce fonksiyonu uygulandı (performans için).

[ ] Kullanıcıya daha iyi geri bildirim sağlamak için yükleme göstergeleri eklendi (örneğin ürünler çekilirken spinner).

[ ] URL'e filtre parametrelerini ekleyerek (URLSearchParams API) sayfa yenilendiğinde filtrelerin korunması sağlandı (ileriki bir adım olabilir).

Bu detaylı rehber ve kontrol listesi ile adım adım ilerleyerek, istediğin tüm özelliklere sahip, sağlam bir giyim mağazası uygulaması geliştirebilirsin. Özellikle applyFiltersAndSort() fonksiyonunun merkeziliği ve her zaman allProducts'tan başlayıp zincirleme filtreleme yapma mantığına odaklan. Başarılar dilerim!